## Yunfei Dai
## 03/31/2020

"""

This script checks if peaks identified by macs2 are close to transcription start sites (TSS).

Input is .narrowPeak file (generated by macs2)

Output is .bed file containing peaks that are close to at least one TSS.

mandatory arguments:

    -i input .narrowPeak file
    -t input TSS list
    -o output file (bed format)

optional arguments:

    -l sequence length desired for query in MEME suite
    -u acceptable upstream distance of peak to TSS
    -d acceptable downstream distance of peak to TSS

"""
from optparse import OptionParser
import pandas as pd

options = OptionParser()

options.add_option("-i", "--input", dest="infile",
                   help="provide input .narrowPeak file")
options.add_option("-t", "--tss", dest="tss",
                   help="provide TSS list")
options.add_option("-l", "--sequence_length", dest="seq_length", type="int", default='500',
                   help="length of resulting sequence region included for meme analysis")
options.add_option("-o", "--output", dest="outfile",
                   help="name of the output file")
options.add_option("-u", "--up_range", dest="up_range", default='50',
                   help="acceptable upstream distance of peak to TSS")
options.add_option("-d", "--down_range", dest="down_range", default='300',
                   help="acceptable downstream distance of peak to TSS")


def tss_peak(narrow_peak, tss, outfile, up_range, down_range, seq_length):
    df_np = pd.read_csv(narrow_peak, sep='\t', names=["ID", "start", "end", "peak", "score", "strand",
                                                      "signalValue", "pValue", "qValue", "offset"])
    df_TSS = pd.read_csv(tss, sep='\t')

    np_index = df_np.index.tolist()  # index for all np sequences
    np_start = df_np["start"].tolist()
    np_peak = df_np["peak"].tolist()
    np_offset = df_np["offset"].tolist()
    np_id = df_np["ID"].tolist()
    tss_index = df_TSS.index.tolist()[:-1]
    tss_coordinate = [int(i) for i in df_TSS["TSS coordinate"].tolist()[:-1]]
    tss_strand = df_TSS["Strand"][:-1].tolist()
    close_np_index = []
    tss_plus = []
    tss_minus = []
    peak_list = []
    for t in tss_index:
        if tss_strand[t] == '+':
            tss_plus.append(tss_coordinate[t])
        else:
            tss_minus.append(tss_coordinate[t])
    for m in np_index:
        np_to_search = np_start[m] + np_offset[m]
        v = binary_search(tss_plus, 0, len(tss_plus) - 1, np_to_search, up_range, down_range)
        w = binary_search(tss_minus, 0, len(tss_minus) - 1, np_to_search, down_range, up_range)
        if v != -1 or w != -1:
            close_np_index.append(m)
            new_start = np_start[m] + np_offset[m] - seq_length
            new_end = np_start[m] + np_offset[m] + seq_length
            peak = np_peak[m]
            id = np_id[m]
            peak_list.append([id, new_start, new_end, peak])
    df = pd.DataFrame(peak_list, columns=['id', 'new start', 'new end', 'peak'])
    df.to_csv(outfile, sep='\t', index=False, header=False)
    print("From file: ", narrow_peak)
    print("Found ", len(close_np_index), " ouf of ", len(np_index), " peaks in range to at least one TSS.")


def binary_search(arr_tss, l, r, p, up, down):
    if r >= l:
        mid = l + (r - l) // 2
        if -up <= p - arr_tss[mid] <= down:
            return mid
        elif p - arr_tss[mid] < -up:
            return binary_search(arr_tss, l, mid - 1, p, up, down)
        else:
            return binary_search(arr_tss, mid + 1, r, p, up, down)
    else:
        return -1


def main():
    (opts, args) = options.parse_args()
    infile = opts.infile
    tss = opts.tss
    outfile = opts.outfile
    down_range = int(opts.down_range)
    up_range = int(opts.up_range)
    seq_length = int(opts.seq_length) // 2

    tss_peak(infile, tss, outfile, up_range, down_range, seq_length)


if __name__ == '__main__':
    main()